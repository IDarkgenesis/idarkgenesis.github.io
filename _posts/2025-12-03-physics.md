---
layout: post
title: Physics
date: 2025-12-03 18:25 +0100
categories: [Projects, Sobrassada Engine]
---

In this task, the Bullet3 physics library was integrated into our engine, along with the creation of the ``Physics module``, ``Capsule collider`` component, ``Cube collider`` component, and ``Sphere collider`` component.

Colliders are categorized into four types:

- **Static**: Objects that can block movement but don't move themselves.

- **Dynamic**: Objects that are moved and influenced by the physics simulation.

- **Kinematic**: Objects that are moved via the update transform from the render world.

- **Trigger**: Objects that donâ€™t interact physically but generate OnCollision events.

![ColliderSettings](/assets/images/SobrassadaEngine/colliderComponentSettings.png)
 _Collider component menu_

The [Physics module](https://github.com/TheCenturiaGames/Sobrassada_Engine/blob/main/SobrassadaEngine/Modules/PhysicsModule.cpp) is responsible for managing the connection between the physics world and the render world. It creates and destroys physics objects and handles collision calls. The physics update is performed during the pre-update phase of the engine, ensuring that all necessary calculations are made before the rendering phase. Additionally, before each physics update, any components marked for deletion are removed from the physics world to prevent them from being processed.

The OnCollision methods are stored in a custom user class using Delegates to avoid dynamic casting when dispatching the collision event to the respective components.

```cpp
#pragma once

#include "ComponentUtils.h"
#include "Delegate.h"

#include "Math/float3.h"

class Component;
class GameObject;

struct SOBRASADA_API_ENGINE BulletUserPointer
{
    BulletUserPointer() = default;
    BulletUserPointer(
        Component* component, CollisionDelegate* onCollisionCall, CollisionDelegate* onCollisionEnterCall,
        CollisionExitDelegate* onCollisionExitCall, bool generateCallback, ColliderLayer newLayer
    )
    {
        collider                 = component;
        onCollisionCallback      = onCollisionCall;
        onCollisionEnterCallback = onCollisionEnterCall;
        onCollisionExitCallback  = onCollisionExitCall;
        this->generateCallback   = generateCallback;
        layer                    = newLayer;
    }

    BulletUserPointer(const BulletUserPointer& otherBulletPointer)
    {
        collider                 = otherBulletPointer.collider;
        onCollisionCallback      = otherBulletPointer.onCollisionCallback;
        onCollisionEnterCallback = otherBulletPointer.onCollisionEnterCallback;
        onCollisionExitCallback  = otherBulletPointer.onCollisionExitCallback;
        generateCallback         = otherBulletPointer.generateCallback;
        layer                    = otherBulletPointer.layer;
    }

    Component* collider;
    CollisionDelegate* onCollisionCallback;
    CollisionDelegate* onCollisionEnterCallback;
    CollisionExitDelegate* onCollisionExitCallback;
    ColliderLayer layer;
    bool generateCallback;
};
```

The physics world supports multiple layers, and their interactions can be fully customized via the engine settings. These settings are saved per scene.

![PhysicsLayer](/assets/images/SobrassadaEngine/physicsLayers.png)
 _Layer configuration_
